<html><body>
<h1>Klassenübersicht</h1>
<h2>Datei: ./modules/argument_parser.py</h2>
<h3>Klasse: ArgumentParser</h3>
<p>Docstring: Klasse zur Analyse von Befehlszeilenargumenten für das Skript.

Attributes:
    help (bool): Gibt an, ob die Hilfe angezeigt werden soll.
    edit_filename (str): Der Name der Datei, die bearbeitet werden soll.
    run_mode (bool): Gibt an, ob der Run-Modus aktiviert ist.
    ki (bool): Gibt an, ob der OpenAI-Modus aktiviert ist.
    server_mode (bool): Gibt an, ob der Server-Modus aktiviert ist.
    example_mode (bool): Gibt an, ob der Beispielmodus aktiviert ist.
    client_id (str): Die ID des Clients.
    prompt (str): Der benutzerdefinierte Prompt.</p>
<p>Methode: __init__(self)</p>
<p>Docstring: Initialisiert die ArgumentParser-Klasse und analysiert die Argumente.</p>
<p>Methode: parse_arguments(self)</p>
<p>Docstring: Analysiert die Befehlszeilenargumente und setzt die entsprechenden Attribute.</p>
<p>Methode: print_help(self)</p>
<p>Docstring: Gibt die Hilfenachricht für das Skript aus.</p>
<h2>Datei: ./modules/backup_manager.py</h2>
<h3>Klasse: BackupManager</h3>
<p>Docstring: Klasse zur Verwaltung von Datei-Backups.

Diese Klasse erstellt Backups von Dateien, indem sie bis zu drei Versionen
der Backup-Datei speichert und sicherstellt, dass die älteste Version überschrieben
wird, wenn eine neue Backup-Datei erstellt wird.

Attributes:
    backup_dir (str): Das Verzeichnis, in dem die Backup-Dateien gespeichert werden.</p>
<p>Methode: __init__(self, backup_dir)</p>
<p>Docstring: Initialisiert die BackupManager-Klasse.

Parameters:
    backup_dir (str): Das Verzeichnis, in dem die Backup-Dateien gespeichert werden. 
                      Standardmäßig 'bak'.</p>
<p>Methode: manage_backups(self, filename)</p>
<p>Docstring: Verwalte die Backups für die angegebene Datei.

Diese Methode erstellt Backups der Datei und verschiebt ältere
Backups auf eine höhere Version (z.B. .bak1 wird zu .bak2).

Parameters:
    filename (str): Der Pfad zur Datei, für die das Backup erstellt werden soll.</p>
<h2>Datei: ./modules/beispiel.py</h2>
<h3>Klasse: ExampleClient</h3>
<p>Docstring: Beispielklasse zum Senden und Empfangen von Nachrichten.

Diese Klasse ermöglicht es, Nachrichten an einen Server zu senden und
empfangene Nachrichten in einem separaten Thread zu verarbeiten.

Attributes:
    client_id (str): Die ID des Clients.
    client (Client): Die Client-Instanz zur Kommunikation mit dem Server.
    running (bool): Gibt an, ob der Client aktiv ist.</p>
<p>Methode: __init__(self, host, port, client_id)</p>
<p>Docstring: Initialisiert die ExampleClient-Klasse.

Parameters:
    host (str): Der Hostname des Servers.
    port (int): Der Port des Servers.
    client_id (str): Die eindeutige ID des Clients.</p>
<p>Methode: start_receiving(self)</p>
<p>Docstring: Wartet auf eingehende Nachrichten und verarbeitet diese.</p>
<p>Methode: send_message_input(self)</p>
<p>Docstring: Ermöglicht dem Benutzer das Senden von Nachrichten an einen Empfänger.</p>
<p>Methode: run(self)</p>
<p>Docstring: Startet den Empfangsthread und die Eingabeaufforderung zum Senden von Nachrichten.</p>
<h2>Datei: ./modules/client.py</h2>
<h3>Klasse: Client</h3>
<p>Docstring: Klasse zur Kommunikation mit einem ZMQ-Server.

Diese Klasse verwaltet die Verbindung zu einem Server, registriert den Client
und ermöglicht das Senden und Empfangen von Nachrichten.

Attributes:
    host (str): Der Hostname des Servers.
    port (int): Der Port des Servers.
    client_id (str): Die eindeutige ID des Clients.
    context: Der ZMQ-Kontext.
    server_socket: Socket zum Senden von Nachrichten an den Server.
    unique_port (int): Einzigartiger Port für den Client.
    listener_socket: Socket zum Empfangen von Nachrichten.</p>
<p>Methode: __init__(self, host, port, client_id)</p>
<p>Docstring: Initialisiert die Client-Klasse.

Parameters:
    host (str): Der Hostname des Servers.
    port (int): Der Port des Servers.
    client_id (str): Die eindeutige ID des Clients.</p>
<p>Methode: generate_unique_port(self)</p>
<p>Docstring: Generiert einen einzigartigen Port für den Client.

Returns:
    int: Ein verfügbarer Port für den Client.</p>
<p>Methode: is_port_available(self, port)</p>
<p>Docstring: Überprüft, ob ein gegebener Port verfügbar ist.

Parameters:
    port (int): Der zu überprüfende Port.

Returns:
    bool: True, wenn der Port verfügbar ist, sonst False.</p>
<p>Methode: register(self)</p>
<p>Docstring: Registriert den Client beim Server.

Sendet eine Registrierungsnachricht an den Server und wartet auf eine Antwort.</p>
<p>Methode: receive_message(self)</p>
<p>Docstring: Empfängt eine Nachricht vom Listener-Socket.

Returns:
    Message: Das empfangene Message-Objekt.

Raises:
    Exception: Wenn ein Fehler beim Empfangen der Nachricht auftritt.</p>
<p>Methode: send_message(self, recipient, sender, message_type, content)</p>
<p>Docstring: Sendet eine Nachricht an den Server.

Parameters:
    recipient (str): Der Empfänger der Nachricht.
    sender (str): Der Absender der Nachricht.
    message_type (str): Der Typ der Nachricht.
    content (str): Der Inhalt der Nachricht.</p>
<h2>Datei: ./modules/code_generator.py</h2>
<h3>Klasse: CodeGenerator</h3>
<p>Docstring: Klasse zur Generierung von Code mithilfe der OpenAI API.

Diese Klasse ermöglicht es, Anfragen an die OpenAI API zu stellen und
generierten Code zurückzugeben.

Attributes:
    api_key (str): Der API-Schlüssel für die OpenAI-Integration.
    organization (str): Die Organisation für die OpenAI-Integration.</p>
<p>Methode: __init__(self, api_key, organization)</p>
<p>Docstring: Initialisiert die CodeGenerator-Klasse.

Parameters:
    api_key (str): Der API-Schlüssel für die OpenAI-Integration.
    organization (str): Die Organisation für die OpenAI-Integration.</p>
<p>Methode: generiere_code(self, messages, model, temperature, max_tokens, frequency_penalty)</p>
<p>Docstring: Generiert Code basierend auf den übergebenen Nachrichten.

Parameters:
    messages (list): Eine Liste von Nachrichten, die als Eingabe an das Modell gesendet werden.
    model (str): Das verwendete Modell. Standardmäßig "gpt-4".
    temperature (float): Steuerung der Kreativität der Ausgabe. Standardmäßig 0.2.
    max_tokens (int): Maximale Anzahl der Tokens für die Antwort. Standardmäßig 4096.
    frequency_penalty (float): Bestrafung für die Wiederholung von Tokens. Standardmäßig 0.2.

Returns:
    str: Der generierte Code oder None, wenn ein Fehler auftritt.</p>
<h2>Datei: ./modules/conversation_manager.py</h2>
<h3>Klasse: ConversationManager</h3>
<p>Docstring: Klasse zur Verwaltung der Konversationshistorie und zur Extraktion von Codeblöcken.

Attributes:
    conversation_history (list): Liste der Nachrichten in der Konversation.
    max_tokens (int): Maximale Anzahl der Tokens, die in der Historie erlaubt sind.
    encoding: Tokenizer für das GPT-4-Modell.
    content_list (list): Liste zum Speichern von Textinhalten und Codeblöcken.
    log_directory (str): Verzeichnis zum Speichern von Logdateien.</p>
<p>Methode: __init__(self, max_tokens)</p>
<p>Docstring: Initialisiert die ConversationManager-Klasse.

Parameters:
    max_tokens (int): Maximale Anzahl der Tokens für die Konversationshistorie.</p>
<p>Methode: add_message(self, role, content)</p>
<p>Docstring: Füge eine Nachricht zur Unterhaltung hinzu.

Parameters:
    role (str): Rolle des Senders (z.B. "user", "system").
    content (str): Inhalt der Nachricht.</p>
<p>Methode: trim_history(self)</p>
<p>Docstring: Kürze die Historie, um die maximale Tokenanzahl zu beachten.</p>
<p>Methode: count_tokens(self, text)</p>
<p>Docstring: Zähle die Anzahl der Tokens in einem Text.

Parameters:
    text (str): Der Text, dessen Tokens gezählt werden sollen.

Returns:
    int: Die Anzahl der Tokens.</p>
<p>Methode: get_history(self)</p>
<p>Docstring: Gibt die gesamte Gesprächshistorie zurück.

Returns:
    list: Die Liste der Nachrichten in der Konversation.</p>
<p>Methode: extract_code_blocks(self, text)</p>
<p>Docstring: Extrahiere Codeblöcke aus dem gegebenen Text.

Parameters:
    text (str): Der Text, aus dem Codeblöcke extrahiert werden sollen.

Returns:
    tuple: Eine Liste von Codeblöcken und der verbleibende Text.</p>
<p>Methode: log_ki_antwort(self, generierter_code)</p>
<p>Docstring: Logge die Antwort der KI in eine Datei.

Parameters:
    generierter_code (str): Die von der KI generierte Antwort, die geloggt werden soll.</p>
<p>Methode: save_content(self, text, code_blocks)</p>
<p>Docstring: Speichere den Text und die Codeblöcke.

Parameters:
    text (str): Der Text, der gespeichert werden soll.
    code_blocks (list): Eine Liste von Codeblöcken, die gespeichert werden sollen.</p>
<p>Methode: remove_empty_codeblocks(self, text)</p>
<p>Docstring: Entferne leere Codeblöcke aus dem Text.

Parameters:
    text (str): Der Text, aus dem leere Codeblöcke entfernt werden sollen.

Returns:
    str: Der bereinigte Text ohne leere Codeblöcke.</p>
<h2>Datei: ./modules/file_manager.py</h2>
<h3>Klasse: FileManager</h3>
<p>Docstring: Klasse zur Verwaltung von Dateien und Nachrichten.

Diese Klasse ermöglicht das Speichern und Verarbeiten von Code,
das Empfangen von Nachrichten über ZMQ und das Erstellen von Backups.

Attributes:
    backup_manager (BackupManager): Die Instanz zur Verwaltung von Backups.
    file_operations (FileOperations): Die Instanz zur Durchführung von Dateioperationen.
    format_code_util (FormatCode): Die Instanz zur Formatierung von Code.
    terminal (Terminal): Die Instanz zur Verwaltung der Benutzereingabe.
    args: Argumente, die beim Starten des FileManagers übergeben wurden.
    running (bool): Gibt an, ob der FileManager aktiv ist.
    main_filename (str): Der Name der Hauptdatei, die verwaltet wird.
    current_code (str): Der aktuell bearbeitete Code.
    client (Client): Die Instanz zur Kommunikation mit dem Server.
    message_thread (threading.Thread): Der Thread zum Empfangen von Nachrichten.</p>
<p>Methode: __init__(self, args, host, port, main_filename, client_id)</p>
<p>Docstring: Initialisiert die FileManager-Klasse.

Parameters:
    args: Argumente, die beim Starten des FileManagers übergeben werden.
    host (str): Der Hostname des Servers.
    port (int): Der Port des Servers.
    main_filename (str): Der Name der Hauptdatei, die verwaltet wird.
    client_id (str): Die eindeutige ID des Clients.</p>
<p>Methode: run(self)</p>
<p>Docstring: Startet den FileManager-Modus und verarbeitet Benutzereingaben.</p>
<p>Methode: receive_messages(self)</p>
<p>Docstring: Empfängt Nachrichten über den ZMQ-Socket und verarbeitet sie.</p>
<p>Methode: save_received_code(self, code)</p>
<p>Docstring: Speichert den empfangenen Code nach Formatierung.

Parameters:
    code (str): Der empfangene Code, der gespeichert werden soll.</p>
<p>Methode: signal_handler(self, sig, frame)</p>
<p>Docstring: Behandelt das Signal zum Beenden des FileManagers.

Parameters:
    sig: Das empfangene Signal.
    frame: Der aktuelle Stack-Frame.</p>
<h2>Datei: ./modules/file_operations.py</h2>
<h3>Klasse: FileOperations</h3>
<p>Docstring: Klasse zur Durchführung von Dateioperationen.

Diese Klasse ermöglicht das Erstellen, Lesen, Schreiben, Löschen und Verwalten von Dateien und Verzeichnissen,
sowie das Verwalten von Backups.

Attributes:
    backup_manager (BackupManager): Die Instanz zur Verwaltung von Backups.</p>
<p>Methode: __init__(self, backup_manager)</p>
<p>Docstring: Initialisiert die FileOperations-Klasse.

Parameters:
    backup_manager (BackupManager): Die Instanz zur Verwaltung von Backups.</p>
<p>Methode: ensure_directory(self, filepath)</p>
<p>Docstring: Stellt sicher, dass das Verzeichnis für den angegebenen Dateipfad existiert.

Parameters:
    filepath (str): Der Pfad zur Datei, für die das Verzeichnis überprüft wird.</p>
<p>Methode: save_file(self, filename, content)</p>
<p>Docstring: Speichert den angegebenen Inhalt in der Datei.

Parameters:
    filename (str): Der Name der Datei, in die der Inhalt geschrieben werden soll.
    content (str): Der Inhalt, der in die Datei geschrieben werden soll.</p>
<p>Methode: delete_file(self, filename)</p>
<p>Docstring: Löscht die angegebene Datei.

Parameters:
    filename (str): Der Name der Datei, die gelöscht werden soll.</p>
<p>Methode: create_directory(self, directory)</p>
<p>Docstring: Erstellt das angegebene Verzeichnis.

Parameters:
    directory (str): Der Name des Verzeichnisses, das erstellt werden soll.</p>
<p>Methode: delete_directory(self, directory)</p>
<p>Docstring: Löscht das angegebene Verzeichnis und seinen Inhalt.

Parameters:
    directory (str): Der Name des Verzeichnisses, das gelöscht werden soll.</p>
<p>Methode: read_file(self, filename)</p>
<p>Docstring: Liest den Inhalt der angegebenen Datei.

Parameters:
    filename (str): Der Name der Datei, die gelesen werden soll.

Returns:
    str: Der Inhalt der Datei oder None, wenn ein Fehler auftritt.</p>
<p>Methode: list_directory_files(self, directory)</p>
<p>Docstring: Listet die Dateien im angegebenen Verzeichnis auf.

Parameters:
    directory (str): Der Pfad zum Verzeichnis, dessen Dateien aufgelistet werden sollen.

Returns:
    list: Eine Liste der Dateien im Verzeichnis oder eine leere Liste, wenn das Verzeichnis nicht existiert.</p>
<p>Methode: list_project_files(self)</p>
<p>Docstring: Listet die Projektdateien im aktuellen Verzeichnis auf.

Diese Methode sucht im Hauptverzeichnis nach der Datei main.py und
im modules-Verzeichnis nach allen Python-Dateien.</p>
<h2>Datei: ./modules/format_code.py</h2>
<h3>Klasse: FormatCode</h3>
<p>Docstring: Klasse zur Formatierung von Code und zur Extraktion von Dateinamen.

Diese Klasse verwendet das 'black'-Modul zur Formatierung von Python-Code
und stellt Methoden zur Verfügung, um Dateinamen aus Kommentaren im Code
zu extrahieren.

Attributes:
    None</p>
<p>Methode: format_code(self, code)</p>
<p>Docstring: Formatiert den gegebenen Code mit dem 'black'-Formatter.

Parameters:
    code (str): Der zu formatierende Python-Code.

Returns:
    str: Der formatierte Code oder der ursprüngliche Code, 
          falls das Formatieren nicht möglich war.</p>
<p>Methode: extract_filename(self, code)</p>
<p>Docstring: Extrahiert den Dateinamen aus dem gegebenen Code.

Sucht nach einem Kommentar im Format '# Filename: <Dateiname>' oder
'# filename: <Dateiname>' und gibt den Dateinamen zurück.

Parameters:
    code (str): Der Code, aus dem der Dateiname extrahiert werden soll.

Returns:
    str: Der extrahierte Dateiname oder None, wenn kein Dateiname gefunden wurde.</p>
<h2>Datei: ./modules/logger.py</h2>
<h3>Klasse: Logger</h3>
<p>Docstring: Klasse zur Protokollierung von Ereignissen in einer Anwendung.

Diese Klasse konfiguriert den Logger, um Nachrichten in eine Logdatei zu schreiben
und umgeleitete Standardausgaben zu protokollieren.

Attributes:
    logger (Logger): Die Logger-Instanz.</p>
<p>Methode: __init__(self, log_file)</p>
<p>Docstring: Initialisiert die Logger-Klasse.

Parameters:
    log_file (str): Der Pfad zur Logdatei. Standardmäßig 'log/app.log'.</p>
<p>Methode: get_logger(self)</p>
<p>Docstring: Gibt die Logger-Instanz zurück.

Returns:
    Logger: Die Logger-Instanz.</p>
<h3>Klasse: StreamToLogger</h3>
<p>Docstring: Hilfsklasse zum Umleiten von Standardausgaben an den Logger.

Attributes:
    logger (Logger): Die Logger-Instanz.
    log_level (int): Der Log-Level für die Umleitung.
    linebuf (str): Buffer für die Zeilen, die geschrieben werden.</p>
<p>Methode: __init__(self, logger, log_level)</p>
<p>Docstring: Initialisiert die StreamToLogger-Klasse.

Parameters:
    logger (Logger): Die Logger-Instanz.
    log_level (int): Der Log-Level für die Umleitung.</p>
<p>Methode: write(self, buf)</p>
<p>Docstring: Schreibt den gegebenen Puffer in den Logger.

Parameters:
    buf (str): Der Puffer mit den zu protokollierenden Nachrichten.</p>
<p>Methode: flush(self)</p>
<p>Docstring: Stellt sicher, dass alle gepufferten Ausgaben geschrieben werden.</p>
<h2>Datei: ./modules/message.py</h2>
<h3>Klasse: Message</h3>
<p>Docstring: Klasse zur Darstellung einer Nachricht zwischen Clients und Servern.

Diese Klasse enthält Informationen über den Empfänger, den Absender,
den Typ der Nachricht und deren Inhalt.

Attributes:
    REGISTER (str): Nachrichtentyp für die Registrierung.
    SEND (str): Nachrichtentyp für das Senden von Nachrichten.
    RESPONSE (str): Nachrichtentyp für Antworten.
    UNKNOWN (str): Nachrichtentyp für unbekannte Nachrichten.
    recipient (str): Der Empfänger der Nachricht.
    sender (str): Der Absender der Nachricht.
    message_type (str): Der Typ der Nachricht.
    content (str): Der Inhalt der Nachricht.</p>
<p>Methode: __init__(self, recipient, sender, message_type, content)</p>
<p>Docstring: Initialisiert die Message-Klasse.

Parameters:
    recipient (str): Der Empfänger der Nachricht.
    sender (str): Der Absender der Nachricht.
    message_type (str): Der Typ der Nachricht.
    content (str): Der Inhalt der Nachricht.</p>
<p>Methode: to_dict(self)</p>
<p>Docstring: Wandelt die Nachricht in ein Wörterbuch um.

Returns:
    dict: Ein Wörterbuch mit den Attributen der Nachricht.</p>
<p>Methode: serialize(self)</p>
<p>Docstring: Serialisiert die Nachricht in ein Byte-Format.

Returns:
    bytes: Die serialisierte Nachricht.</p>
<p>Methode: deserialize(serialized_message)</p>
<p>Docstring: Deserialisiert eine Byte-Nachricht zurück in ein Message-Objekt.

Parameters:
    serialized_message (bytes): Die serialisierte Nachricht.

Returns:
    Message: Das deserialisierte Message-Objekt.</p>
<h2>Datei: ./modules/openai.py</h2>
<h3>Klasse: OpenAIIntegration</h3>
<p>Docstring: Klasse zur Integration mit OpenAI, die die Kommunikation mit der OpenAI-API verwaltet
und die Verarbeitung von Benutzeranfragen sowie die Extraktion von Codeblöcken übernimmt.

Attributes:
    api_key (str): Der API-Schlüssel für die OpenAI-Integration.
    organization (str): Die Organisation für die OpenAI-Integration.
    prompt (str): Der Start-Prompt für die Konversation.
    total_tokens (int): Die Gesamtanzahl der bisher verwendeten Tokens.
    client (CodeGenerator): Der CodeGenerator zur Generierung von Code.
    conversation_manager (ConversationManager): Verwaltet die Konversationshistorie.
    encoding: Tokenizer für das GPT-4-Modell.
    running (bool): Gibt an, ob die Instanz aktiv ist.
    receiver_thread (threading.Thread): Thread zum Empfang von Nachrichten.</p>
<p>Methode: __init__(self, args, host, port, api_key, organization, prompt, client_id)</p>
<p>Docstring: Initialisiert die OpenAIIntegration-Klasse.

Parameters:
    args: Die Argumente, die beim Start der Anwendung übergeben wurden.
    host (str): Der Hostname des Servers.
    port (int): Der Port des Servers.
    api_key (str): Der API-Schlüssel für die OpenAI-Integration.
    organization (str): Die Organisation für die OpenAI-Integration.
    prompt (str): Der Start-Prompt für die Konversation.
    client_id (str): Die eindeutige ID des Clients.</p>
<p>Methode: start_receiving(self)</p>
<p>Docstring: Wartet auf eingehende Nachrichten über ZMQ und verarbeitet diese.</p>
<p>Methode: process_file_content(self, file_content)</p>
<p>Docstring: Verarbeitet den empfangenen Datei-Inhalt und generiert eine Antwort von OpenAI.

Parameters:
    file_content (str): Der Inhalt der empfangenen Datei.</p>
<p>Methode: send_code_blocks(self, code_blocks)</p>
<p>Docstring: Sendet die extrahierten Codeblöcke einzeln an den FileManager.

Parameters:
    code_blocks (list): Eine Liste von Codeblöcken, die gesendet werden sollen.</p>
<p>Methode: run_interactive_mode(self)</p>
<p>Docstring: Startet den interaktiven Modus zur Verarbeitung von Benutzeranfragen.</p>
<p>Methode: read_multiline_input(self, prompt)</p>
<p>Docstring: Liest mehrzeilige Benutzereingaben.

Parameters:
    prompt (str): Der Text, der als Eingabeaufforderung angezeigt wird.

Returns:
    str: Der eingegebene mehrzeilige Text.</p>
<p>Methode: count_tokens(self, text)</p>
<p>Docstring: Zählt die Anzahl der Tokens in einem gegebenen Text.

Parameters:
    text (str): Der Text, dessen Tokens gezählt werden sollen.

Returns:
    int: Die Anzahl der Tokens.</p>
<h2>Datei: ./modules/run.py</h2>
<h3>Klasse: Run</h3>
<p>Docstring: Klasse zur Ausführung eines Clients, der mit einem Server kommuniziert.

Diese Klasse ermöglicht das Empfangen von Befehlen über einen Client
und deren Ausführung im System.

Attributes:
    server_address (tuple): Die Adresse des Servers (Host, Port).
    running (bool): Status, ob der Client aktiv ist oder nicht.
    client_id (str): Die ID des Clients.
    client (Client): Die Instanz des Clients zur Kommunikation mit dem Server.
    message_thread (threading.Thread): Der Thread zum Empfangen von Nachrichten.</p>
<p>Methode: __init__(self, args, host, port, client_id)</p>
<p>Docstring: Initialisiert die Run-Klasse und registriert den Client.

Parameters:
    args: Die übergebenen Argumente.
    host (str): Der Hostname des Servers.
    port (int): Der Port, auf dem der Server lauscht.
    client_id (str): Die ID des Clients.</p>
<p>Methode: signal_handler(self, sig, frame)</p>
<p>Docstring: Behandelt das Signal für Strg+C, um den Client zu beenden.

Parameters:
    sig: Das empfangene Signal.
    frame: Der aktuelle Stack-Frame.</p>
<p>Methode: handle_message(self, message)</p>
<p>Docstring: Verarbeitet die empfangene Nachricht.

Parameters:
    message (bytes): Die empfangene serialisierte Nachricht.</p>
<p>Methode: receive_messages(self)</p>
<p>Docstring: Wartet auf eingehende Nachrichten und verarbeitet diese.</p>
<p>Methode: start(self)</p>
<p>Docstring: Startet den Run-Client und wartet auf Befehle.</p>
<h2>Datei: ./modules/server.py</h2>
<h3>Klasse: ServerHandler</h3>
<p>Docstring: Klasse zur Verwaltung eines ZMQ-Servers.

Diese Klasse ermöglicht das Empfangen von Nachrichten von Clients,
die Verarbeitung dieser Nachrichten und das Senden von Antworten.

Attributes:
    host (str): Der Hostname des Servers.
    port (int): Der Port, auf dem der Server lauscht.
    context (zmq.Context): Der ZMQ-Kontext.
    socket (zmq.REP): Der ZMQ-Socket, der für den Empfang von Nachrichten verwendet wird.
    clients (dict): Ein Dictionary zur Speicherung der registrierten Clients.</p>
<p>Methode: __init__(self, host, port)</p>
<p>Docstring: Initialisiert die ServerHandler-Klasse.

Parameters:
    host (str): Der Hostname des Servers.
    port (int): Der Port, auf dem der Server lauscht.</p>
<p>Methode: start_server(self)</p>
<p>Docstring: Startet den Server und wartet auf eingehende Nachrichten.</p>
<p>Methode: process_message(self, message)</p>
<p>Docstring: Verarbeitet die empfangene Nachricht und gibt eine Antwort zurück.

Parameters:
    message (Message): Die empfangene Nachricht.

Returns:
    Message: Die Antwortnachricht.</p>
<p>Methode: send_to_client(self, address, message)</p>
<p>Docstring: Sendet eine Nachricht an den angegebenen Client.

Parameters:
    address (str): Die Adresse des Clients.
    message (Message): Die zu sendende Nachricht.</p>
<p>Methode: signal_handler(self, sig, frame)</p>
<p>Docstring: Behandelt das Signal zum Beenden des Servers.

Parameters:
    sig: Das empfangene Signal.
    frame: Der aktuelle Stack-Frame.</p>
<p>Methode: shutdown_server(self)</p>
<p>Docstring: Schließt den Server und gibt Ressourcen frei.</p>
<h2>Datei: ./modules/terminal.py</h2>
<h3>Klasse: Terminal</h3>
<p>Docstring: Klasse zur Verwaltung der Terminal-Eingaben.

Diese Klasse ermöglicht das Lesen von Benutzereingaben im Terminal
und behandelt spezielle Steuerbefehle wie Strg+C, Strg+D, Strg+F und Strg+L.

Attributes:
    file_operations (FileOperations): Instanz der FileOperations-Klasse.
    old_settings: Alte Terminal-Einstellungen zur Wiederherstellung.
    running (bool): Status, ob das Terminal aktiv ist oder nicht.</p>
<p>Methode: __init__(self, file_operations)</p>
<p>Docstring: Initialisiert die Terminal-Klasse.

Parameters:
    file_operations (FileOperations): Instanz der FileOperations-Klasse.</p>
<p>Methode: signal_handler(self, sig, frame)</p>
<p>Docstring: Behandelt das Signal für Strg+C, um das Programm zu beenden.

Parameters:
    sig: Das empfangene Signal.
    frame: Der aktuelle Stack-Frame.</p>
<p>Methode: reset_terminal(self)</p>
<p>Docstring: Setzt die Terminal-Einstellungen auf die alten Werte zurück.</p>
<p>Methode: read_input(self)</p>
<p>Docstring: Liest Benutzereingaben im Terminal und verarbeitet Steuerbefehle.

Returns:
    tuple: Ein Tuple, das den eingegebenen Code (oder None) und die Aktion enthält.</p>
</body></html>